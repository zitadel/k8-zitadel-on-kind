{"_timestamp":1757148097374630,"file":"/var/log/pods/traefik-system_traefik-787bbd48dc-tvpjk_c982d59d-4e15-4a77-a2d3-9fd26d2d164e/traefik/0.log","kubernetes_container_id":"containerd://57bf13e556083ecda5c8f77bb6d6dc3f75bedbfa07c701a762dfc947cf37b90f","kubernetes_container_image":"ghcr.io/traefik/traefik:v3.4.5","kubernetes_container_image_id":"ghcr.io/traefik/traefik@sha256:06ddf61ee653caf4f4211a604e657f084f4727f762c16f826c97aafbefcb279e","kubernetes_container_name":"traefik","kubernetes_namespace_labels_kubernetes_io_metadata_name":"traefik-system","kubernetes_namespace_labels_name":"traefik-system","kubernetes_node_labels_beta_kubernetes_io_arch":"arm64","kubernetes_node_labels_beta_kubernetes_io_os":"linux","kubernetes_node_labels_kubernetes_io_arch":"arm64","kubernetes_node_labels_kubernetes_io_hostname":"desktop-control-plane","kubernetes_node_labels_kubernetes_io_os":"linux","kubernetes_node_labels_node_role_kubernetes_io_control_plane":"","kubernetes_pod_annotations_prometheus_io_path":"/metrics","kubernetes_pod_annotations_prometheus_io_port":"9100","kubernetes_pod_annotations_prometheus_io_scrape":"true","kubernetes_pod_ip":"10.244.0.19","kubernetes_pod_ips":"[\"10.244.0.19\"]","kubernetes_pod_labels_app_kubernetes_io_instance":"traefik-traefik-system","kubernetes_pod_labels_app_kubernetes_io_managed_by":"Helm","kubernetes_pod_labels_app_kubernetes_io_name":"traefik","kubernetes_pod_labels_helm_sh_chart":"traefik-37.0.0","kubernetes_pod_labels_pod_template_hash":"787bbd48dc","kubernetes_pod_name":"traefik-787bbd48dc-tvpjk","kubernetes_pod_namespace":"traefik-system","kubernetes_pod_node_name":"desktop-control-plane","kubernetes_pod_owner":"ReplicaSet/traefik-787bbd48dc","kubernetes_pod_uid":"c982d59d-4e15-4a77-a2d3-9fd26d2d164e","message":"\u001b[90m2025-09-06T08:41:36Z\u001b[0m \u001b[31mERR\u001b[0m \u001b[1mError configuring TLS\u001b[0m \u001b[36merror=\u001b[0m\u001b[31m\u001b[1m\"secret observability/openobserve.example.com does not exist\"\u001b[0m\u001b[0m \u001b[36mingress=\u001b[0mopenobserve-openobserve-standalone \u001b[36mnamespace=\u001b[0mobservability \u001b[36mproviderName=\u001b[0mkubernetes","source_type":"kubernetes_logs","stream":"stdout","timestamp":"2025-09-06T08:41:36.681905002Z"}

# Ensure a string and strip ANSI, infallibly
msg = to_string!(.message)
clean = strip_ansi_escape_codes!(msg)

# Capture everything after level as message
re_pat = r'^(?P<timestamp>\S+)\s+(?P<level>\S+)\s+(?P<message>.*)$'
parsed, err = parse_regex(clean, re_pat)

if err == null {
  lvl = upcase!(to_string!(parsed.level))

  std = if (lvl == "ERR" || lvl == "ERROR") { "error" } else {
          if (lvl == "WARN" || lvl == "WARNING") { "warn" } else {
            if (lvl == "INFO") { "info" } else {
              if (lvl == "DEBUG") { "debug" } else { downcase!(lvl) }
            }
          }
        }

  .level = std
  .message = strip_whitespace!(to_string!(parsed.message))
}


